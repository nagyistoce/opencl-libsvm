#pragma OPENCL EXTENSION cl_khr_fp64: enabletypedef struct svm_struct{    int index;    double value;}svm_struct;typedef struct param_struct_dot{    double common_label;}param_struct_dot;typedef struct param_struct_poly{    double common_label;    double gamma;    double coef0;    int degree;}param_struct_poly;typedef struct param_struct_sigmoid{    double common_label;    double gamma;    double coef0;}param_struct_sigmoid;__kernel void sparseDotASaco(__global const svm_struct* data, __global const int * feats, __local double *vecin, __global double *res,__global double *res2, param_struct_dot set_data, int len, int max_features, int first, int last){    size_t local_i = get_global_id(0);       //index for the output vector    size_t i = local_i+first;       //each one of the vectors to compute (max get_global_id(0) = last-first)    size_t j = get_global_id(1);             //each one of the "versus". max get_global_id(1) = l         double prod = res2[j] * res2[i];        if(i >= first && i < last) {                int start_index = feats[i];        int finish_index = feats[i+len];                   int z = 0;        while(z+j < max_features) {        	vecin[z+j] = 0;        	z = z + get_local_size(1);        }        barrier(CLK_LOCAL_MEM_FENCE);                //z=start_index;        //while(z+j < finish_index) {        //	vecin[data[z+j].index] = data[z+j].value;        //	z = z + get_local_size(1);        //}        //barrier(CLK_LOCAL_MEM_FENCE);                        //for(int k = 0; k < max_features;  ++k) vecin[k] = 0;                for(int z = start_index; z < finish_index; ++z) vecin[data[z].index] = data[z].value;          ////barrier(CLK_LOCAL_MEM_FENCE);                        if(j<len) {            //each thread compute a dot product            start_index = feats[j];            finish_index = feats[j+len];            double cosa = 0;            for(int z = start_index; z < finish_index; ++z) cosa += (data[z].value*vecin[data[z].index]);            res[local_i*len+j] = cosa*prod;        }    }    else {    	barrier(CLK_LOCAL_MEM_FENCE);    	//barrier(CLK_LOCAL_MEM_FENCE);    }}__kernel void sparseDot(__global const svm_struct* data, __global const int * feats, __global const double *vecin, __global double *res,__global double *res2,  param_struct_dot set_data, int l){    size_t i =  get_global_id(0);    if(i<l) {    int first = feats[i];    int top = feats[i+l];    double prod = set_data.common_label * res2[i];    double cosa = 0;    for(int z = first; z < top; ++z) {       cosa += (data[z].value*vecin[data[z].index]);    }    res[i] = cosa*prod;    }}__kernel void sparsePoly(__global const svm_struct* data, __global const int * feats, __global const double *vecin, __global double *res,__global double *res2,  param_struct_poly set_data, int l){    size_t i =  get_global_id(0);    if(i<l) {    double prod = set_data.common_label * res2[i];    double gamma = set_data.gamma; double coef0 = set_data.coef0; int degree = set_data.degree;     int first = feats[i];    int top = feats[i+l];    double cosa = 0;    for(int z = first; z < top; ++z) {       cosa += (data[z].value*vecin[data[z].index]);    }    res[i] = pown(gamma*cosa+coef0, degree)*prod;    }}__kernel void sparseSigmoid(__global const svm_struct* data, __global const int * feats, __global const double *vecin, __global double *res,__global double *res2,  param_struct_sigmoid set_data, int l){    size_t i =  get_global_id(0);    if(i<l) {    double gamma = set_data.gamma; double coef0 = set_data.coef0;    int first = feats[i];    int top = feats[i+l];    double prod = set_data.common_label * res2[i];    double cosa = 0;    for(int z = first; z < top; ++z) {       cosa += (data[z].value*vecin[data[z].index]);    }    res[i] = tanh(gamma*cosa+coef0)*prod;    }}typedef struct param_struct_rbf {    double common_label;    double gamma;    double common_x_square;    }param_struct_rbf;__kernel void sparseRBF(__global const svm_struct* data, __global const int * feats, __global const double *vecin, __global double *res,__global double *res2,param_struct_rbf set_data, int l, __global double *x_square){    size_t i =  get_global_id(0);    if(i<l) {    double gamma = -set_data.gamma; double x_square_i = x_square[i]; double common_x_square =set_data.common_x_square; double common_label = set_data.common_label;    int first = feats[i];    int top = feats[i+l];    double prod = common_label * res2[i];    double cosa = 0;    for(int z = first; z < top; ++z) {       cosa += (data[z].value*vecin[data[z].index]);    }    res[i] = exp(gamma*(-2*cosa+x_square_i+common_x_square))*prod;    }}